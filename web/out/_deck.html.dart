// Auto-generated from deck.html.
// DO NOT EDIT.

library x_card_deck;

import 'dart:html' as autogenerated;
import 'package:web_components/watcher.dart' as autogenerated;

import 'package:web_components/web_components.dart';

import '../model.dart';

import '../playing_cards.dart';

import '_card.html.dart';

class CardDeckComponent extends WebComponent {
  
  /** Autogenerated from the template. */
  
  /**
  * Shadow root for this component. We use 'var' to allow simulating shadow DOM
  * on browsers that don't support this feature.
  */
  var _root;
  autogenerated.HeadingElement __e0;
  
  autogenerated.WatcherDisposer _stopWatcher__e0_1;
  
  autogenerated.DivElement __e3;
  
  autogenerated.UnknownElement __e2;
  
  // Fields for template list 'x in cards'
  autogenerated.WatcherDisposer _stopWatcher__e1;
  List<autogenerated.WatcherDisposer> _removeChild__e1 = [];
  
  autogenerated.HeadingElement __e4;
  
  autogenerated.WatcherDisposer _stopWatcher__e4_2;
  
  CardDeckComponent.forElement(e) : super.forElement(e) {
    _root = createShadowRoot();
  }
  
  void created_autogenerated() {
    _root.innerHTML = '''
    
    <h2 id="__e-0"></h2>
    <div class="hand" id="__e-3">
    <template id="__e-2" style="display:none"></template>
    </div>
    <h2 id="__e-4"></h2>
    <!--		</div> -->
    ''';
    __e0 = _root.query('#__e-0');
    
    __e3 = _root.query('#__e-3');
    
    __e2 = __e3.query('#__e-2');
    
    __e4 = _root.query('#__e-4');
    
  }
  
  void inserted_autogenerated() {
    _stopWatcher__e0_1 = autogenerated.watchAndInvoke(() => deckName, (e) {
      __e0.innerHTML = '${deckName}';
    });
    
    _stopWatcher__e1 = autogenerated.watchAndInvoke(() => cards, (e) {
      for (var remover in _removeChild__e1) remover();
      _removeChild__e1.clear();
      
      var _insert__e1 = __e2.nextNode;
      
      for (var x in cards) {
        
        autogenerated.UnknownElement __e1;
        
        __e1 = new autogenerated.Element.html('''
        <x-playing-card></x-playing-card>''');
        var component__e1 = new PlayingCardComponent.forElement(__e1);
        component__e1.card = x;
        component__e1.created_autogenerated();
        component__e1.created();
        
        __e2.parent.insertBefore(__e1, _insert__e1);
        
        // Attach listeners/watchers
        
        __e1.xtag.inserted();
        __e1.xtag.inserted_autogenerated();
        
        // Remember to unregister them
        
        _removeChild__e1.add(() {
          
          __e1.remove();
          
          __e1.xtag.removed_autogenerated();
          __e1.xtag.removed();
          __e1 = null;
          
        });
      }
    });
    
    _stopWatcher__e4_2 = autogenerated.watchAndInvoke(() => status, (e) {
      __e4.innerHTML = '${status}';
    });
    
  }
  
  void removed_autogenerated() {
    _stopWatcher__e0_1();
    
    __e0 = null;
    
    __e3 = null;
    
    _stopWatcher__e1();
    for (var remover in _removeChild__e1) remover();
    _removeChild__e1.clear();
    
    __e2 = null;
    
    _stopWatcher__e4_2();
    
    __e4 = null;
    
  }
  
  /** Original code from the component. */
  
  Deck deck;
  //String deckName;
  List<Card> get cards{
    return deck.cards;
  }
  String get status{
    String result = '';
    if(deck.isDealer){
      result = '$result Dealer ';
    }
    else if(deck.isNextToPlay){
      result = '$result Next to Play';
    }
    return result;
  }
  String get deckName => deck.name;
  String get deckClasses{
    //print(deck.name);
    return (deck.name == 'dealer' ? 'deck' : '') ;
  }
}

