// Auto-generated from deck.html.
// DO NOT EDIT.

library x_card_deck;

import 'dart:html' as autogenerated;
import 'package:web_components/web_components.dart' as autogenerated;

import 'package:web_components/web_components.dart';

import '../model.dart';

import '../playing_cards.dart';

import 'card.html.dart';

class CardDeckComponent extends WebComponent {
  
  /** Autogenerated from the template. */
  
  /**
  * Shadow root for this component. We use 'var' to allow simulating shadow DOM
  * on browsers that don't support this feature.
  */
  var _root;
  autogenerated.HeadingElement __e1;
  
  var _binding0;
  
  List<autogenerated.WatcherDisposer> _stoppers1;
  
  autogenerated.UnknownElement __e3;
  
  List<Function> _removeChild__e3 = [];
  
  autogenerated.Node _endPosition__e3;
  
  autogenerated.HeadingElement __e5;
  
  var _binding4;
  
  CardDeckComponent.forElement(e) : super.forElement(e);
  
  void created_autogenerated() {
    _root = createShadowRoot();
    
    _root.innerHTML = '''
    
    <h2 id="__e-1"></h2>
    <div class="hand">
    <template id="__e-3" style="display:none"></template>
    </div>
    <h2 id="__e-5"></h2>
    <!--		</div> -->
    ''';
    __e1 = _root.query('#__e-1');
    _binding0 = autogenerated.nodeForBinding(deckName);
    _stoppers1 = [];
    __e1.nodes.add(_binding0);
    __e3 = _root.query('#__e-3');
    __e5 = _root.query('#__e-5');
    _binding4 = autogenerated.nodeForBinding(status);
    __e5.nodes.add(_binding4);
    
  }
  
  void inserted_autogenerated() {
    _stoppers1.add(autogenerated.watchAndInvoke(() => deckName, (__e) { _binding0 = autogenerated.updateBinding(__e.newValue, _binding0); }));
    
    _endPosition__e3 = __e3;
    
    _stoppers1.add(autogenerated.watchAndInvoke(() => cards, (_) {
      for (var remover in _removeChild__e3) remover();
      _removeChild__e3.clear();
      
      _endPosition__e3 = autogenerated.removeNodes(__e3, _endPosition__e3);
      
      var __insert___e3 = __e3.nextNode;
      
      for (var x in cards) {
        
        autogenerated.UnknownElement __e2;
        
        __e2 = new autogenerated.Element.tag('x-playing-card');
        var component__e2 = new PlayingCardComponent.forElement(__e2);
        component__e2.card = x;
        component__e2.created_autogenerated();
        component__e2.created();
        component__e2.composeChildren();
        
        autogenerated.insertAllBefore(__e3.parent, __insert___e3,
        
        [_endPosition__e3 = __e2]);
        
        __e2.xtag.inserted();
        __e2.xtag.inserted_autogenerated();
        
        _removeChild__e3.add(() {
          
          __e2.xtag.removed_autogenerated();
          __e2.xtag.removed();
          __e2 = null;
          
        });
      }
    }));
    
    _stoppers1.add(autogenerated.watchAndInvoke(() => status, (__e) { _binding4 = autogenerated.updateBinding(__e.newValue, _binding4); }));
    
  }
  
  void removed_autogenerated() {
    _root = null;
    
    __e1 = null;
    
    (_stoppers1..forEach((s) => s())).clear();
    
    _binding0 = null;
    
    _endPosition__e3 = autogenerated.removeNodes(__e3, _endPosition__e3);
    
    for (var remover in _removeChild__e3) remover();
    _removeChild__e3.clear();
    
    __e3 = null;
    
    __e5 = null;
    
    _binding4 = null;
    
  }
  
  /** Original code from the component. */
  
  Deck deck;
  //String deckName;
  List<Card> get cards{
    return deck.cards.values;
  }
  String get status{
    String result = '';
    if(deck.isDealer){
      result = '$result Dealer ';
    }
    else if(deck.isNextToPlay){
      result = '$result Next to Play';
    }
    return result;
  }
  String get deckName => deck.name;
  String get deckClasses{
    //print(deck.name);
    return (deck.name == 'dealer' ? 'deck' : '') ;
  }
}

